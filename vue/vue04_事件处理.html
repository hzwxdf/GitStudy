<!DOCTYPE html>
<html>
<head>
	<title>Vue-事件处理</title>
	<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>

<h3>v-on绑定dom监听事件</h3>
<div id="app">
  <p>
    事件监听
  </p>
  <button v-on:click="count" id="btn" class="class1 class2"><span>直接绑定一个方法：点击数字加1</span></button>
  <button v-on:click="user_count('这是调用的方法', $event)" id="btn" class="class1 class2"><span>内联中调用方法</span></button>
  <p>
    {{ sum }}
  </p>
  <label>事件修饰符</label>
  <p>
    在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。
    为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。
    .stop
    .prevent
    .capture
    .self
    .once
    .passive<br>
    事件修饰符的顺序很重要.事件修饰符可以连缀使用.例如v-on:click.prevent.stop。
  </p>
  <!-- 阻止单击事件继续传播 -->
  <a v-on:click.stop="doThis"></a>

  <!-- 提交事件不再重载页面 -->
  <form v-on:submit.prevent="onSubmit"></form>

  <!-- 修饰符可以串联 -->
  <a v-on:click.stop.prevent="doThat"></a>

  <!-- 只有修饰符 -->
  <form v-on:submit.prevent></form>

  <!-- 添加事件监听器时使用事件捕获模式 -->
  <!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
  <div v-on:click.capture="doThis">...</div>

  <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
  <!-- 即事件不是从内部元素触发的 -->
  <div v-on:click.self="doThat">...</div>

  <!-- 点击事件将只会触发一次 -->
  <a v-on:click.once="doThis"></a>

  <!-- Vue 还对应 addEventListener 中的 passive 选项提供了 .passive 修饰符。 -->
  <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
  <!-- 而不会等待 `onScroll` 完成  -->
  <!-- 这其中包含 `event.preventDefault()` 的情况 -->
  <div v-on:scroll.passive="onScroll">...</div>
</div>
<script type="text/javascript">
  var vm2 =new Vue({
    el: '#app',
    data: {
      sum: 0,
    },
    methods: {
      count: function(event){
        console.log("你点击了一次")
        this.sum = this.sum + 1
        console.log("事件event对象的属性方法有以下：")
        console.log(event.target)
        console.log(event.target.id)
        console.log(event.target.tagName)
        console.log(event.target.nodeName)
        console.log(event.target.innerHTML)
        console.log(event.target.innerText)
        console.log(event.target.classList)
        /*
        事件event对象的属性方法有以下：
        vue04_事件处理.html:30 <button id=​"btn" class=​"class1 class2">​…​</button>​
        vue04_事件处理.html:31 btn
        vue04_事件处理.html:32 BUTTON
        vue04_事件处理.html:33 BUTTON
        vue04_事件处理.html:34 <span>点击数字加1</span>
        vue04_事件处理.html:35 点击数字加1
        vue04_事件处理.html:36 DOMTokenList(2) ["class1", "class2", value: "class1 class2"]
        */
      },
      user_count: function(msg, event){
        alert("方法调用：" + msg + "==使用$event传递事件对象过来："+ event.target)
      }
    }
  })
</script>

<h3>按键修饰符</h3>
<div id="app2">
  <p>按键修饰符
  为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：
  .enter
  .tab
  .delete (捕获“删除”和“退格”键)
  .esc
  .space
  .up
  .down
  .left
  .right
  </p>
  <input
   v-on:keyup.enter="et('enter')"
   v-on:keyup.space="et('space')"
  >
  <p>keyCodes按键码被废弃
  你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名：
  // 可以使用 `v-on:keyup.f1`
  Vue.config.keyCodes.f1 = 112
  </p>
  <input v-on:keyup.f1="et('f1')">
  <p>
    可以用如下系统修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。
    .ctrl
    .alt
    .shift
    .meta
  </p>
  <!-- v-on的缩写@,同时按下alt和c -->
  <input @keyup.alt.67="et('alt+c')">
  <p>.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
  <!-- 按下alt也按下其他键也有效 -->
  <input @keyup.alt="et('alt+oter')">
  <!-- 只按下alt有效 -->
  <input @keyup.alt.exact="et('alt')">
  <p>
    鼠标按钮修饰符
    .left
    .right
    .middle
  </p>
  <p
    style="width: 200px;height: 200px;border: 1px solid red;"
    @click.left="et('鼠标左键')"
    @click.right="et('鼠标右键')"
    @click.middle="et('鼠标中建')"
  >

  </p>
</div>
<script type="text/javascript">
  var vm2 = new Vue({
    el: '#app2',
    data: {

    },
    methods: {
      et: function(msg){
        console.log("你按下了:" + msg)
      }
    }
  })
  Vue.config.keyCodes.f1 = 112
</script>


</body>
</html>